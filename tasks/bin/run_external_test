#!/usr/bin/env ruby

# This script helps to test external gems in the content of the current
# Chef install. We want to make sure that the external gems will still function
# once we release Chef so we run *their* specs against the current contents
# of the chef / ohai repos. It let's us know if we need to update downstream
# gems or fix regressions in chef *before* we release.

$:.unshift(File.expand_path("../../lib", __dir__))

require "tmpdir"
require "bundler"
require "chef/mixin/shell_out"

include Chef::Mixin::ShellOut

github_repo = ARGV.shift
git_thing = ARGV.shift || "main" # Default to 'main' if no branch/tag specified

build_dir = Dir.pwd

env = {
  "GEMFILE_MOD" => "gem 'chef', path: '#{build_dir}'; " \
    "gem 'ohai', git: 'https://github.com/chef/ohai.git', branch: '18-stable'",
  "CHEF_LICENSE" => "accept-no-persist",
}

# Knife-windows requires the chef-licensing gem to execute the tests.
env["GEMFILE_MOD"] += "; gem 'chef-licensing'" if github_repo == "chef/knife-windows"

Dir.mktmpdir("chef-external-test") do |tmpdir|
  git_url = "https://github.com/#{github_repo}"
  clone_dir = File.join(tmpdir, "repo")
  
  # Clone the repository with error handling and timeout
  begin
    shell_out!("git clone --depth=1 \"#{git_url}\" \"#{clone_dir}\"", live_stream: STDOUT, timeout: 600)
  rescue => e
    puts "Failed to clone #{git_url}: #{e.message}"
    exit 1
  end
  
  Dir.chdir(clone_dir) do
    # Checkout the specified branch/tag if different from what was cloned
    if git_thing != "main"
      begin
        # Try to checkout the specified branch/tag
        # First, try direct checkout (for existing branches)
        result = shell_out("git checkout \"#{git_thing}\"", live_stream: STDOUT, timeout: 300)
        if result.exitstatus != 0
          # If direct checkout fails, try fetching and then checkout
          shell_out!("git fetch --depth=1 origin \"#{git_thing}\"", live_stream: STDOUT, timeout: 300)
          shell_out!("git checkout \"#{git_thing}\"", live_stream: STDOUT)
        end
      rescue => e
        puts "Failed to checkout #{git_thing}: #{e.message}"
        puts "Proceeding with the default branch"
      end
    else
      # Even for "main", ensure we're on the right branch
      begin
        result = shell_out("git checkout \"#{git_thing}\"", live_stream: STDOUT, timeout: 300)
        if result.exitstatus != 0
          # If main doesn't exist, try master or stay on current branch
          puts "Branch 'main' not found, trying 'master' or staying on current branch"
          result = shell_out("git checkout master", live_stream: STDOUT, timeout: 300)
          if result.exitstatus != 0
            puts "Using current default branch"
          end
        end
      rescue => e
        puts "Warning: Could not checkout main branch: #{e.message}"
        puts "Proceeding with current branch"
      end
    end
    
    Bundler.with_unbundled_env do
      shell_out!("bundle install --jobs=3 --retry=3", live_stream: STDOUT, env: env, timeout: 3600)
      shell_out!("bundle exec #{ARGV.join(" ")}", live_stream: STDOUT, env: env)
    end
  end
end
